<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>What If Analysis Board</title>
    <meta name="theme-color" content="#111827">
  <link rel="manifest" href="manifest.json">
  <link rel="icon" href="icons/casl-icon.svg" type="image/svg+xml">
  <link rel="apple-touch-icon" href="chess/wk.png">
  
    <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Casl">
  
  
  
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; font-family: 'Inter', sans-serif; }
    body {
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: linear-gradient(120deg, #f7f7f7, #ebebeb);
      color: #222;
      padding: 16px;
    }
    .panel {
      width: min(100%, 860px);
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 12px;
      padding: 16px;
      display: grid;
      gap: 12px;
    }
    .topbar {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
    }
    .hint {
      font-size: 0.9rem;
      color: #555;
    }
    .layout {
      display: flex;
      gap: 16px;
      align-items: flex-start;
      flex-wrap: wrap;
    }
    .board-wrap {
      position: relative;
      width: 480px;
      height: 480px;
      border: 2px solid #222;
      box-shadow: 0 6px 20px rgba(0,0,0,0.15);
    }
    #board {
      position: absolute;
      inset: 0;
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
      z-index: 1;
    }
    #arrows {
      position: absolute;
      inset: 0;
      z-index: 2;
      pointer-events: none;
    }
    .square {
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }
    .light { background: #f0d9b5; }
    .dark { background: #b58863; }
    .selected { outline: 3px solid #2e7d32; outline-offset: -3px; }
    .last-move { box-shadow: inset 0 0 0 3px #fff59d; }
    .square img {
      width: 82%;
      height: 82%;
      pointer-events: auto;
      user-select: none;
    }
    .side {
      display: grid;
      gap: 10px;
      min-width: 220px;
    }
    .card {
      border: 1px solid #ddd;
      border-radius: 10px;
      padding: 10px;
      background: #fafafa;
    }
    .card h3 {
      font-size: 0.95rem;
      margin-bottom: 6px;
    }
    .line {
      font-size: 0.9rem;
      color: #333;
      word-break: break-word;
    }
    button {
      border: none;
      background: #2e7d32;
      color: white;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
    }
    button:hover { background: #43a047; }
    @media (max-width: 760px) {
      .board-wrap {
        width: min(92vw, 420px);
        height: min(92vw, 420px);
      }
    }
  </style>
</head>
<body>
  <div class="panel">
    <div class="topbar">
      <button id="back-btn">Back</button>
      <div class="hint" id="status">Normal board loaded. Move pieces to analyze.</div>
      <button id="reset-btn">Reset Board</button>
    </div>

    <div class="layout">
      <div class="board-wrap">
        <canvas id="arrows"></canvas>
        <div id="board"></div>
      </div>

      <div class="side">
        <div class="card">
          <h3>Best Move For White</h3>
          <div class="line" id="best-white">-</div>
        </div>
        <div class="card">
          <h3>Best Move For Black</h3>
          <div class="line" id="best-black">-</div>
        </div>
        <div class="card">
          <h3>FEN</h3>
          <div class="line" id="fen-text"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const boardEl = document.getElementById('board');
    const canvas = document.getElementById('arrows');
    const statusEl = document.getElementById('status');
    const bestWhiteEl = document.getElementById('best-white');
    const bestBlackEl = document.getElementById('best-black');
    const fenTextEl = document.getElementById('fen-text');
    const backBtn = document.getElementById('back-btn');
    const resetBtn = document.getElementById('reset-btn');

    const startSetup = [
      ['br','bn','bb','bq','bk','bb','bn','br'],
      ['bp','bp','bp','bp','bp','bp','bp','bp'],
      ['','','','','','','',''],
      ['','','','','','','',''],
      ['','','','','','','',''],
      ['','','','','','','',''],
      ['wp','wp','wp','wp','wp','wp','wp','wp'],
      ['wr','wn','wb','wq','wk','wb','wn','wr'],
    ];

    let boardState = startSetup.map(row => [...row]);
    let selected = null;
    let moveCount = 0;
    let lastMove = null;
    let engine = null;
    let engineReady = false;
    let pendingSide = null;
    let analysisVersion = 0;
    let bestWhite = '-';
    let bestBlack = '-';
    let draggedFrom = null;

    function pieceToFen(piece) {
      if (!piece) return '';
      const map = { p: 'p', r: 'r', n: 'n', b: 'b', q: 'q', k: 'k' };
      const base = map[piece[1]] || 'p';
      return piece[0] === 'w' ? base.toUpperCase() : base;
    }

    function boardToFen(sideToMove) {
      const rows = [];
      for (let r = 0; r < 8; r++) {
        let rowFen = '';
        let empty = 0;
        for (let f = 0; f < 8; f++) {
          const piece = pieceToFen(boardState[r][f]);
          if (!piece) {
            empty++;
          } else {
            if (empty > 0) rowFen += String(empty);
            empty = 0;
            rowFen += piece;
          }
        }
        if (empty > 0) rowFen += String(empty);
        rows.push(rowFen);
      }
      const fullMove = Math.floor(moveCount / 2) + 1;
      return `${rows.join('/')} ${sideToMove} - - 0 ${fullMove}`;
    }

    function squareToCoord(square) {
      const file = square.charCodeAt(0) - 97;
      const rank = Number(square[1]);
      return [8 - rank, file];
    }

    function drawArrow(move, color) {
      if (!move || move.length < 4) return;
      const from = squareToCoord(move.slice(0, 2));
      const to = squareToCoord(move.slice(2, 4));
      const ctx = canvas.getContext('2d');
      const size = canvas.width / 8;
      const x1 = from[1] * size + size / 2;
      const y1 = from[0] * size + size / 2;
      const x2 = to[1] * size + size / 2;
      const y2 = to[0] * size + size / 2;

      const angle = Math.atan2(y2 - y1, x2 - x1);
      const head = size * 0.28;

      ctx.strokeStyle = color;
      ctx.fillStyle = color;
      ctx.lineWidth = Math.max(4, size * 0.1);
      ctx.lineCap = 'round';

      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(x2, y2);
      ctx.lineTo(x2 - head * Math.cos(angle - Math.PI / 7), y2 - head * Math.sin(angle - Math.PI / 7));
      ctx.lineTo(x2 - head * Math.cos(angle + Math.PI / 7), y2 - head * Math.sin(angle + Math.PI / 7));
      ctx.closePath();
      ctx.fill();
    }

    function resizeCanvas() {
      const rect = boardEl.getBoundingClientRect();
      canvas.width = Math.floor(rect.width);
      canvas.height = Math.floor(rect.height);
      drawBestMoveArrows();
    }

    function drawBestMoveArrows() {
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawArrow(bestWhite, 'rgba(255, 140, 0, 0.92)');
      drawArrow(bestBlack, 'rgba(255, 170, 60, 0.85)');
    }

    function renderBoard() {
      boardEl.innerHTML = '';
      for (let r = 0; r < 8; r++) {
        for (let f = 0; f < 8; f++) {
          const sq = document.createElement('div');
          sq.className = `square ${(r + f) % 2 === 0 ? 'light' : 'dark'}`;
          if (selected && selected[0] === r && selected[1] === f) sq.classList.add('selected');
          if (lastMove && ((lastMove.from[0] === r && lastMove.from[1] === f) || (lastMove.to[0] === r && lastMove.to[1] === f))) {
            sq.classList.add('last-move');
          }
          const piece = boardState[r][f];
          if (piece) {
            const img = document.createElement('img');
            img.src = `chess/${piece}.png`;
            img.draggable = true;
            img.addEventListener('dragstart', (event) => {
              draggedFrom = [r, f];
              event.dataTransfer.effectAllowed = 'move';
            });
            sq.appendChild(img);
          }
          sq.addEventListener('dragover', (event) => {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
          });
          sq.addEventListener('drop', (event) => {
            event.preventDefault();
            if (!draggedFrom) return;
            tryMove(draggedFrom[0], draggedFrom[1], r, f);
            draggedFrom = null;
          });
          sq.addEventListener('click', () => handleClick(r, f));
          boardEl.appendChild(sq);
        }
      }
      fenTextEl.textContent = boardToFen(moveCount % 2 === 0 ? 'w' : 'b');
      resizeCanvas();
    }

    function setBestMoves(white, black) {
      bestWhite = white || '-';
      bestBlack = black || '-';
      bestWhiteEl.textContent = bestWhite;
      bestBlackEl.textContent = bestBlack;
      drawBestMoveArrows();
    }

    function requestAnalysis(side, version) {
      pendingSide = { side, version };
      engine.postMessage('stop');
      engine.postMessage(`position fen ${boardToFen(side)}`);
      engine.postMessage('go depth 12');
    }

    function analyzeBothSides() {
      if (!engine) {
        statusEl.textContent = 'Engine unavailable.';
        return;
      }
      if (!engineReady) {
        statusEl.textContent = 'Engine loading...';
        return;
      }
      analysisVersion++;
      const v = analysisVersion;
      setBestMoves('-', '-');
      statusEl.textContent = 'Analyzing white and black best moves...';
      requestAnalysis('w', v);
    }

    const STOCKFISH_SOURCES = [
      'Engine/stockfish.wasm.js',
      'https://cdn.jsdelivr.net/npm/stockfish.js@10.0.2/stockfish.wasm.js'
    ];

    function handleEngineMessage(event) {
      const line = String(event.data || '');
      if (!line.startsWith('bestmove ') || !pendingSide) return;

      const move = line.split(/\s+/)[1] || '-';
      const safeMove = move === '(none)' ? '-' : move;
      const current = pendingSide;
      pendingSide = null;
      if (current.version !== analysisVersion) return;

      if (current.side === 'w') {
        bestWhite = safeMove;
        bestWhiteEl.textContent = bestWhite;
        requestAnalysis('b', current.version);
      } else {
        bestBlack = safeMove;
        bestBlackEl.textContent = bestBlack;
        drawBestMoveArrows();
        statusEl.textContent = 'Analysis updated for both sides.';
      }
    }

    function handleEngineError() {
      statusEl.textContent = 'Engine error during analysis.';
    }

    function tryStartEngine(workerUrl) {
      return new Promise((resolve, reject) => {
        let candidate = null;
        let finished = false;
        const timeoutId = setTimeout(() => fail(new Error('uci timeout')), 8000);

        function cleanup() {
          clearTimeout(timeoutId);
        }

        function fail(error) {
          if (finished) return;
          finished = true;
          cleanup();
          if (candidate) {
            try { candidate.terminate(); } catch (_) {}
          }
          reject(error);
        }

        try {
          candidate = new Worker(workerUrl);
        } catch (error) {
          fail(error);
          return;
        }

        candidate.onmessage = (event) => {
          const line = String(event.data || '');
          if (line !== 'uciok') return;
          if (finished) return;
          finished = true;
          cleanup();
          candidate.onmessage = handleEngineMessage;
          candidate.onerror = handleEngineError;
          resolve(candidate);
        };

        candidate.onerror = () => fail(new Error('worker start error'));
        candidate.postMessage('uci');
        candidate.postMessage('isready');
      });
    }

    async function initEngine() {
      engine = null;
      engineReady = false;
      statusEl.textContent = 'Loading analysis engine...';

      for (const source of STOCKFISH_SOURCES) {
        try {
          engine = await tryStartEngine(source);
          engineReady = true;
          statusEl.textContent = 'Engine ready. Move any piece to update arrows.';
          analyzeBothSides();
          return;
        } catch (_) {}
      }

      statusEl.textContent = 'Engine unavailable.';
    }

    function handleClick(r, f) {
      if (selected) {
        if (selected[0] === r && selected[1] === f) {
          selected = null;
          renderBoard();
          return;
        }
        tryMove(selected[0], selected[1], r, f);
        selected = null;
        return;
      }
      if (!boardState[r][f]) return;
      selected = [r, f];
      renderBoard();
    }

    function tryMove(fromR, fromF, toR, toF) {
      if (!boardState[fromR][fromF]) return;
      boardState[toR][toF] = boardState[fromR][fromF];
      boardState[fromR][fromF] = '';
      lastMove = { from: [fromR, fromF], to: [toR, toF] };
      moveCount++;
      renderBoard();
      analyzeBothSides();
    }

    backBtn.addEventListener('click', () => {
      window.location.href = 'index.html';
    });

    resetBtn.addEventListener('click', () => {
      boardState = startSetup.map(row => [...row]);
      selected = null;
      moveCount = 0;
      lastMove = null;
      setBestMoves('-', '-');
      renderBoard();
      analyzeBothSides();
    });

    window.addEventListener('resize', resizeCanvas);

    renderBoard();
    initEngine();
  </script>
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('service-worker.js').catch(() => {});
      });
    }
  </script>
</body>
</html>









